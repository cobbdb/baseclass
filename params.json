{"name":"Baseclass","tagline":"Lean yet robust JavaScript inheritance.","body":"# BaseClass [![Bower version](https://badge.fury.io/bo/baseclass.svg)](http://badge.fury.io/bo/baseclass) [![NPM version](https://badge.fury.io/js/baseclassjs.svg)](http://badge.fury.io/js/baseclassjs)\r\n\r\nLean yet robust JavaScript inheritance.\r\n\r\n    $ bower install baseclassjs\r\n    $ npm install baseclassjs\r\n\r\n-------------\r\nBaseClass is an alternative to many of the overbearing and intrusive inheritance libraries\r\nsuch as Ember and even Fiber. Code in natural JavaScript but now with the power of simple\r\ninheritance.\r\n\r\nBaseClass is provided as a node and Browserify module, as well as a global function. You can\r\npick whichever version you prefer. The node and Browserify module lives in:\r\n`dist/node/baseclass.min.js`, and the global function lives in `dist/bower/baseclass.min.js`.\r\n\r\n## BaseClass() & extend()\r\nHere's a quick example showing a typical class setup.\r\n\r\n```javascript\r\n// pet.js\r\nvar BaseClass = require('baseclassjs');\r\nmodule.exports = function (name) {\r\n    // Declare your root class with the BaseClass constructor.\r\n    return BaseClass({\r\n        name: name,\r\n        speak: function () {\r\n            console.log('Hi there!');\r\n        }\r\n    });\r\n};\r\n```\r\n```javascript\r\n// dog.js\r\nvar Pet = require('./pet.js');\r\nmodule.exports = function (name) {\r\n    return Pet(name).extend({\r\n        color: 'grey',\r\n        speak: function () {\r\n            this.base.speak();\r\n            console.log(\"I'm \" + name + \" and I'm a \"  + this.color + ' dog.');\r\n        }\r\n    });\r\n};\r\n```\r\n```javascript\r\n// my-app.js\r\nvar Dog = require('./dog.js');\r\nvar woofie = Dog('Woofie');\r\nwoofie.speak(); // --> Hi there! I'm Woofie and I'm a grey dog.\r\n```\r\n\r\nThis inheritance chain can continue on as deep as you want it to be. To reach deeper into the\r\nchain, just use the `.base` notation. For example if you want data from two levels deep, that\r\nwould look like `child.base.base.data`.\r\n\r\nSince all properties are brought over to each child, children will always have access to an `extend`\r\nmethod to create more children.\r\n\r\n#### this.base\r\nAny child can access its parent with the `base` property. This is provided automatically to\r\neach child and works in the same way as Java's `super` keyword.\r\n\r\n#### this.leaf\r\nSometimes a parent needs to access its children. In classical languages this is when type\r\ncasting comes into play, but we don't have that in JavaScript. Instead any parent can\r\naccess its leaf-most child with the `leaf` attribute. This is provided automatically at\r\nevery level of inheritance - meaning that even the top child will have a `leaf`\r\nproperty pointing to itself.\r\n\r\n## BaseClass.Abstract\r\nIf you want your base class to enforce an override, you can use the `Abstract` method provided\r\nfrom the BaseClass function. Simply drop it into place like this:\r\n\r\n```javascript\r\n// vehicle.js\r\nvar Vehicle = function (model) {\r\n    return BaseClass({\r\n        model: model,\r\n        // Drop it in like any other property.\r\n        drive: BaseClass.Abstract\r\n    });\r\n};\r\n```\r\n```javascript\r\n// car.js\r\nvar Car = function (model) {\r\n    return Vehicle(model).extend({\r\n        color: 'blue'\r\n        // Notice we did -not- override the drive() method.\r\n    });\r\n};\r\n```\r\n```javascript\r\n// my-app.js\r\nvar whip = Car('Honda');\r\nwhip.drive(); // --> Throws JS Error!\r\n```\r\n\r\nCalling an abstract method that has not been overridden will result in a JS Error being thrown.\r\n\r\n## BaseClass.Stub\r\nSometimes you only want to reserve an attribute name to ensure that it's provided to all children.\r\nThis can be done easily with the `Stub` method.\r\n\r\n```javascript\r\n// vehicle.js\r\nvar Vehicle = function (model) {\r\n    return BaseClass({\r\n        model: model,\r\n        // Drop it in like any other property.\r\n        honk: BaseClass.Stub\r\n    });\r\n};\r\n```\r\n```javascript\r\n// car.js\r\nvar Car = function (model) {\r\n    return Vehicle(model).extend({\r\n        weight: '1000lbs'\r\n        // Notice we did -not- override the honk() method.\r\n    });\r\n};\r\n```\r\n```javascript\r\n// my-app.js\r\nvar whip = Car('Honda');\r\nwhip.honk(); // --> Nothing happens.\r\n```\r\n\r\n## BaseClass.Interface() & implement()\r\nIf you only want to attach attributes without changing an\r\nobject's type, you can define an `Interface`. All children\r\ncontain an `implement()` method used to attach one or more\r\ninterfaces.\r\n\r\n```javascript\r\n// honkable.js\r\nvar BaseClass = require('baseclassjs');\r\nmodule.exports = BaseClass.Interface({\r\n    honk: function () {\r\n        return 'beep beep';\r\n    }\r\n});\r\n```\r\n```javascript\r\n// car.js\r\nvar Vehicle = require('./vehicle.js'),\r\n    Honkable = require('./honkable.js'),\r\n    Driveable = require('./driveable.js');\r\nmodule.exports = function (model) {\r\n    return Vehicle(model).extend({\r\n        weight: '1000lbs'\r\n    }).implement(\r\n        Honkable,\r\n        Driveable\r\n    );\r\n};\r\n```\r\n```javascript\r\n// myapp.js\r\nvar Car = require('./cat.js');\r\nmyride = Car('honda');\r\nmyride.honk(); // --> beep beep\r\n```\r\n\r\n---------\r\n* See: http://cobbdb.github.io/baseclass\r\n* See: http://github.com/cobbdb/baseclass\r\n* License: MIT\r\n","google":"UA-50240363-6","note":"Don't delete this file! It's used internally to help with page regeneration."}