{"name":"Baseclass","tagline":"Lean yet robust JavaScript inheritance.","body":"# BaseClass [![Bower version](https://badge.fury.io/bo/baseclass.svg)](http://badge.fury.io/bo/baseclass) [![NPM version](https://badge.fury.io/js/baseclassjs.svg)](http://badge.fury.io/js/baseclassjs)\r\n\r\nLean yet robust JavaScript inheritance.\r\n\r\n    $ bower install baseclassjs\r\n    $ npm install baseclassjs\r\n\r\n[![NPM info](https://nodei.co/npm/baseclassjs.png?stars=true&downloads=true)](https://nodei.co/npm-dl/baseclassjs/)[![NPM downloads](https://nodei.co/npm-dl/baseclassjs.png?months=6&height=2)](https://nodei.co/npm-dl/baseclassjs/)\r\n\r\n-------------\r\nBaseClass is a fast, lightweight, and non-intrusive inheritance\r\nlibrary. Code in natural JavaScript but now with the power of\r\nsimple inheritance.\r\n\r\nBaseClass is provided as a CommonJS module, as well as a global function.\r\nYou can pick whichever version you prefer. The global function lives\r\nin `dist/baseclass.min.js`, and the CommonJS module can be `require`'d\r\nafter it is `npm install`'d.\r\n\r\n## BaseClass() & extend()\r\nHere's a quick example showing a typical class setup.\r\n\r\n```javascript\r\n// pet.js\r\nvar BaseClass = require('baseclassjs');\r\nmodule.exports = function (name) {\r\n    // Declare your root class with the BaseClass constructor.\r\n    return BaseClass({\r\n        name: name,\r\n        color: 'grey',\r\n        speak: function () {\r\n            console.log('Hi there!');\r\n        }\r\n    });\r\n};\r\n```\r\n```javascript\r\n// dog.js\r\nvar Pet = require('./pet.js');\r\nmodule.exports = function (name) {\r\n    return Pet(name).extend({\r\n        // The 'this.base' object is used to access a parent's methods.\r\n        speak: function () {\r\n            this.base.speak();\r\n            console.log(\"I'm \" + name + \" and I'm a \"  + this.color + ' dog.');\r\n        }\r\n    });\r\n};\r\n```\r\n```javascript\r\n// my-app.js\r\nvar Dog = require('./dog.js'),\r\n    woofie = Dog('Woofie');\r\nwoofie.speak(); // --> Hi there! I'm Woofie and I'm a grey dog.\r\n```\r\n\r\nThis inheritance chain can continue on as deep as you want it to be. To\r\nreach deeper into the chain, just use the `.base` notation. For example\r\nif you want data from two levels deep, that would look\r\nlike `child.base.base.data`.\r\n\r\nSince all properties are brought over to each child, children will always\r\nhave access to an `extend` method to create more children.\r\n\r\n#### _create method\r\nAll levels of the inheritance chain are assigned a `_create` method. This\r\nmethod is stubbed when not explicitly defined. The `_create` method is\r\na callback that executes after the root parent is created and again after\r\neach child is extended. The `this` object is bound to the newly setup\r\ninstance. Here is an example of populating a custom data-structure after\r\nit has been newly created.\r\n```javascript\r\n// Where MyCollection provides an add() method.\r\nmodule.exports = function () {\r\n    return MyCollection().extend({\r\n        _create: function () {\r\n            this.add([1, 2, 3, 4]);\r\n        }\r\n    });\r\n};\r\n```\r\n\r\n#### this.base & this.self\r\nAny child can access its parent's methods with the `this.base` object.\r\nThis is provided automatically to each child method and works in the\r\nsame way as Java's `super` keyword.\r\n\r\nLikewise, since the `this` keyword always points at the leaf-most child,\r\nparents can access themselves with the `this.self` object. `this.self` is\r\nintended for those rare situations when your code does not want to run the\r\nleaf-most override of a function, but rather the function at its own\r\ninheritance level.\r\n\r\nHere is an example using both `this.base` and `this.self`:\r\n\r\n```javascript\r\nfunction Machine() {\r\n    return BaseClass({\r\n        alarm: function () {\r\n            return 'alert: ';\r\n        }\r\n    });\r\n}\r\n```\r\n```javascript\r\nfunction Vehicle() {\r\n    return Machine().extend({\r\n        honk: function () {\r\n            return 'beep beep';\r\n        },\r\n        alarm: function (msg) {\r\n            msg += this.base.alarm();\r\n            return msg + this.self.honk();\r\n        }\r\n    });\r\n}\r\n```\r\n```javascript\r\nfunction Car() {\r\n    return Vehicle().extend({\r\n        honk: function () {\r\n            return 'ahooooga';\r\n        }\r\n    });\r\n}\r\n```\r\n```javascript\r\n// my-app.js\r\nvar mycar = Car();\r\nconsole.log(mycar.honk()); // --> ahooooga\r\nconsole.log(mycar.alarm('!> ')); // --> !> alert: beep beep\r\n```\r\n\r\n## BaseClass.Abstract\r\nIf you want your base class to enforce an override, you can use the\r\n`Abstract` method provided from the BaseClass function. Simply drop it into\r\nplace like this:\r\n\r\n```javascript\r\nfunction Vehicle(model) {\r\n    return BaseClass({\r\n        model: model,\r\n        // Drop it in like any other property.\r\n        drive: BaseClass.Abstract\r\n    });\r\n}\r\n```\r\n```javascript\r\nfunction Car(model) {\r\n    return Vehicle(model).extend({\r\n        color: 'blue'\r\n        // Notice we did -not- override the drive() method.\r\n    });\r\n}\r\n```\r\n```javascript\r\n// my-app.js\r\nvar mycar = Car('Honda');\r\nmycar.drive(); // --> Throws JS Error!\r\n```\r\n\r\nCalling an abstract method that has not been overridden will result in a\r\nJS Error being thrown.\r\n\r\n## BaseClass.Stub\r\nSometimes you only want to reserve an attribute name to ensure that it's\r\nprovided to all children. This can be done easily with the `Stub` method.\r\n\r\n```javascript\r\n// vehicle.js\r\nvar Vehicle = function (model) {\r\n    return BaseClass({\r\n        model: model,\r\n        // Drop it in like any other property.\r\n        honk: BaseClass.Stub\r\n    });\r\n};\r\n```\r\n```javascript\r\n// car.js\r\nvar Car = function (model) {\r\n    return Vehicle(model).extend({\r\n        weight: '1000lbs'\r\n        // Notice we did -not- override the honk() method.\r\n    });\r\n};\r\n```\r\n```javascript\r\n// my-app.js\r\nvar whip = Car('Honda');\r\nwhip.honk(); // --> Nothing happens.\r\n```\r\n\r\n## BaseClass.Interface() & implement()\r\nIf you only want to attach attributes without changing an\r\nobject's type, you can define an `Interface`. All children\r\ncontain an `implement()` method used to attach one or more\r\ninterfaces.\r\n\r\n```javascript\r\n// honkable.js\r\nvar BaseClass = require('baseclassjs');\r\nmodule.exports = BaseClass.Interface({\r\n    honk: function () {\r\n        return 'beep beep';\r\n    }\r\n});\r\n```\r\n```javascript\r\n// car.js\r\nvar Vehicle = require('./vehicle.js'),\r\n    Honkable = require('./honkable.js'),\r\n    Driveable = require('./driveable.js');\r\nmodule.exports = function (model) {\r\n    return Vehicle(model).extend({\r\n        weight: '1000lbs'\r\n    }).implement(\r\n        Honkable,\r\n        Driveable\r\n    );\r\n};\r\n```\r\n```javascript\r\n// myapp.js\r\nvar Car = require('./cat.js');\r\nmycar = Car('honda');\r\nmycar.honk(); // --> beep beep\r\n```\r\n\r\n---------\r\n* See: http://cobbdb.github.io/baseclass\r\n* See: http://github.com/cobbdb/baseclass\r\n* License: MIT\r\n","google":"UA-50240363-6","note":"Don't delete this file! It's used internally to help with page regeneration."}